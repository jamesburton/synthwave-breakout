<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Synthwave Breakout</title>
  <style>
    html, body { margin:0; height:100%; background:#05050a; overflow:hidden; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #hud { position:fixed; top:0; left:0; right:0; padding:8px 12px; display:flex; gap:16px; justify-content:space-between; align-items:center; color:#e6e6ff; mix-blend-mode:screen; pointer-events:none; text-shadow:0 0 8px #7af, 0 0 16px #7af; }
    #hud .left, #hud .right { display:flex; gap:16px; align-items:center; }
    #hud .pill { background:rgba(10,10,20,0.5); border:1px solid rgba(120,180,255,0.35); padding:6px 10px; border-radius:999px; box-shadow:0 0 12px rgba(120,180,255,0.3) inset; }
    #menu { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:radial-gradient(ellipse at center, rgba(10,10,30,0.85), rgba(5,5,10,0.95)); color:#e6e6ff; flex-direction:column; gap:16px; text-align:center; }
    #menu h1 { font-size:42px; letter-spacing:2px; text-shadow:0 0 24px #f0f; }
    #menu button { pointer-events:auto; padding:10px 18px; border-radius:999px; border:1px solid #7af; background:rgba(20,20,40,0.9); color:#cfe8ff; cursor:pointer; box-shadow:0 0 18px rgba(120,180,255,0.35), inset 0 0 12px rgba(255,0,255,0.25); }
    #menu button:hover { filter:brightness(1.15); }
    #menu .row{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;}
    #hiscores{font-size:14px; opacity:0.9}
    canvas { display:block; }
  </style>

  <!-- Import map so bare specifiers resolve without a bundler -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="hud">
    <div class="left">
      <div class="pill" id="score">Score: 0</div>
      <div class="pill" id="lives">Lives: 3</div>
      <div class="pill" id="level">Level: 1</div>
      <div class="pill" id="mult">x1.0</div>
    </div>
    <div class="right">
      <div class="pill" id="weapon">Laser: OFF</div>
      <div class="pill" id="energy">Energy: 0%</div>
      <div class="pill" id="shieldHud">Shield: OFF</div>
    </div>
  </div>
  <div id="menu">
    <h1>ðŸŸ£ SYNTHWAVE BREAKOUT</h1>
    <div>Move with mouse/touch. Space/Click: launch & laser. P: pause.</div>
    <div id="hiscores">Top 5: <span id="hiscoreList">â€”</span></div>
    <div class="row">
      <button id="startBtn">Start Game</button>
      <button id="toggleBloom">Toggle Bloom</button>
      <button id="toggleFlash">Reduce Flashing</button>
      <button id="resetScores">Reset Scores</button>
    </div>
  </div>

  <script type="module">
    // ---------- Imports via import map ----------
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // ---------- Config ----------
    const CONFIG = {
      WORLD: { WIDTH: 160, HEIGHT: 90, WALL_THICK: 2 },
      PADDLE: { WIDTH: 18, HEIGHT: 2.5, SPEED: 220, MAX_WIDTH: 30 },
      BALL: { RADIUS: 1.4, SPEED: 75, MAX_SPEED: 150 },
      LASER: { COST: 12, RECHARGE_HIT: 6, COOLDOWN: 0.15, SPEED: 250 },
      POWERUPS: { FALL_SPEED: 22, CHANCE: 0.15, DURATION: 12 },
      SCORE: { BASE: 10, ARMORED: 20, STEEL: 0, EXPLOSIVE: 40, MULT_MAX: 5 },
      TRAIL: { SPAWN_DT: 0.025, LIFE: 0.5, SIZE: 2.2 },
      MOVERS: { AMP: 6.0, SPEED: 0.8 },
    };

    const COLORS = {
      neonCyan: new THREE.Color('#53e3fb'),
      neonMagenta: new THREE.Color('#ff3df5'),
      neonPurple: new THREE.Color('#a96bff'),
      steel: new THREE.Color('#7b8aa6'),
      dark: new THREE.Color('#0b0f1a'),
      white: new THREE.Color('#ffffff'),
      neonGreen: new THREE.Color('#78ffcb'),
      amber: new THREE.Color('#ffd36b'),
    };

    const SETTINGS = { bloom: true, reduceFlashing: false, highContrast: false, volume: 0.6 };

    // ---------- Utilities ----------
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a=0,b=1)=>a+Math.random()*(b-a);

    // Simple pub/sub
    const Events = (()=>{ const m={}; return { on:(k,f)=>(m[k]??=[]).push(f), emit:(k,...a)=> (m[k]||[]).forEach(f=>f(...a)) }; })();

    // ---------- Audio (WebAudio synth) ----------
    const AudioSys = (()=>{
      let ctx; const master = {gain:null};
      function ensure(){ if(!ctx){ ctx=new (window.AudioContext||window.webkitAudioContext)(); master.gain=ctx.createGain(); master.gain.gain.value=SETTINGS.volume; master.gain.connect(ctx.destination);} }
      function beep(freq=440, dur=0.08, type='sine', vol=0.3){ ensure(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.type=type; o.frequency.value=freq; o.connect(g); g.connect(master.gain); g.gain.setValueAtTime(vol, ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+dur); o.start(); o.stop(ctx.currentTime+dur); }
      const api={
        bounce:()=>beep(420+rand(-40,40),0.04,'sine',0.15),
        brick:()=>beep(660+rand(-60,60),0.06,'triangle',0.22),
        armored:()=>beep(280+rand(-20,20),0.08,'square',0.18),
        steel:()=>beep(180,0.12,'sawtooth',0.16),
        laser:()=>beep(1200,0.05,'square',0.25),
        power:()=>beep(900,0.12,'triangle',0.2),
        lose:()=>{beep(160,0.18,'sawtooth',0.25); setTimeout(()=>beep(120,0.22,'triangle',0.25),120);},
        level:()=>{beep(720,0.08,'square',0.22); setTimeout(()=>beep(980,0.08,'square',0.22),90);},
      };
      return api;
    })();

    // ---------- Shaders ----------
    const BG_VERT = /* glsl */`varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0); }`;
    const BG_FRAG = /* glsl */`
      precision highp float; varying vec2 vUv; uniform float uTime; uniform float uIntensity; 
      float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453123); }
      float noise(in vec2 p){ vec2 i=floor(p), f=fract(p); float a=hash(i), b=hash(i+vec2(1,0)), c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
        vec2 u=f*f*(3.0-2.0*f); return mix(a,b,u.x)+ (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y; }
      void main(){
        vec2 uv = vUv; uv.x *= 1.777; 
        float t = uTime*0.03;
        float n = 0.0; 
        n += noise(uv*2.0 + t*vec2(0.6,0.4))*0.7;
        n += noise(uv*4.0 - t*vec2(0.2,0.5))*0.5;
        n += noise(uv*8.0 + t*vec2(-0.3,0.2))*0.25;
        float stars = smoothstep(0.995,1.0, hash(floor(uv*vec2(800.0, 450.0) + t*60.0)) );
        vec3 col = vec3(0.02,0.02,0.06) + vec3(0.6,0.1,0.8)*n*0.6 + vec3(0.7,0.9,1.0)*stars*0.7*uIntensity;
        gl_FragColor = vec4(col,1.0);
      }
    `;

    const NEON_FRAG = /* glsl */`
      precision highp float; varying vec2 vUv; uniform vec3 uColor; uniform float uTime; uniform float uHit;
      void main(){
        vec2 uv=vUv*2.0-1.0; float r=length(uv);
        float rim = smoothstep(0.5, 1.0, 1.0 - r);
        float pulse = 0.5 + 0.5*sin(uTime*8.0 + r*6.283);
        float hit = uHit>0.0 ? exp(-uHit*4.0)*1.5 : 0.0;
        vec3 c = uColor*(0.4 + 0.6*pulse) + uColor*rim*0.6 + vec3(hit);
        gl_FragColor = vec4(c, 1.0);
      }
    `;

    const RING_FRAG = /* glsl */`precision mediump float; varying vec2 vUv; uniform vec3 uColor; uniform float uTime; void main(){ vec2 uv=vUv*2.0-1.0; float d=length(uv); float a = smoothstep(0.25,0.24,d) * (1.0 - smoothstep(0.55,0.56,d)); float fade = max(0.0, 1.0 - uTime); gl_FragColor = vec4(uColor, a*fade); }`;
    const LASER_FRAG = /* glsl */`precision mediump float; varying vec2 vUv; uniform vec3 uColor; void main(){ float d = abs(vUv.y-0.5); float core = smoothstep(0.05,0.0,d); float glow = smoothstep(0.25,0.05,d)*0.6; gl_FragColor = vec4(uColor*(core+glow), core+glow); }`;
    const SHIELD_FRAG = /* glsl */`precision mediump float; varying vec2 vUv; uniform vec3 uColor; uniform float uPulse; void main(){ float y=vUv.y; float a = smoothstep(0.0,0.1,y) * (1.0 - smoothstep(0.9,1.0,y)); float glow = 0.4 + 0.6*abs(sin(uPulse*6.283)); gl_FragColor = vec4(uColor*glow, a*0.9); }`;

    // ---------- Level Data ----------
    const LEVELS = [
      { name:'Neon Dawn', rowMoves:[0,1,0.6,0,0], rows: [
        [0,0,0,0,0,5,1,1,1,5,0,0,0,0,0],
        [0,0,0,1,1,1,2,2,2,1,1,1,0,0,0],
        [0,0,1,1,4,1,1,3,1,1,4,1,1,0,0],
        [0,1,1,2,2,2,1,1,1,2,2,2,1,1,0],
        [1,1,1,1,1,1,5,0,5,1,1,1,1,1,1]
      ]},
      { name:'Grid Runner', rowMoves:[1,0,1,0.5,0], rows:[
        [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
        [0,2,0,2,0,2,0,2,0,2,0,2,0,2,0],
        [1,0,1,0,1,0,3,0,3,0,1,0,1,0,1],
        [0,5,0,4,0,5,0,4,0,5,0,4,0,5,0],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
      ]},
      { name:'Pulse', rowMoves:[0,0.8,0,0.4,0], rows:[
        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
        [1,0,0,0,0,0,5,0,5,0,0,0,0,0,1],
        [1,0,3,2,2,2,1,1,1,2,2,2,3,0,1],
        [1,0,0,0,4,0,0,1,0,0,4,0,0,0,1],
        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,0]
      ]},
    ];
    while(LEVELS.length<12){ const base=LEVELS[LEVELS.length%3]; const copy=JSON.parse(JSON.stringify(base)); copy.name += ' +' + (LEVELS.length+1); LEVELS.push(copy); }

    // ---------- Game State ----------
    let renderer, scene, camera, composer, bloomPass, bgMesh;
    const world = CONFIG.WORLD;

    const hud = {
      score: document.getElementById('score'),
      lives: document.getElementById('lives'),
      level: document.getElementById('level'),
      mult: document.getElementById('mult'),
      weapon: document.getElementById('weapon'),
      energy: document.getElementById('energy'),
      shield: document.getElementById('shieldHud'),
      menu: document.getElementById('menu'),
      hiscoreList: document.getElementById('hiscoreList'),
      startBtn: document.getElementById('startBtn'),
      toggleBloom: document.getElementById('toggleBloom'),
      toggleFlash: document.getElementById('toggleFlash'),
      resetScores: document.getElementById('resetScores'),
    };

    const state = {
      running:false, paused:false,
      levelIndex:0, score:0, lives:3, mult:1,
      balls:[], bricks:[], powerups:[], projectiles:[], effects:[], trails:[], movers:[],
      laser:{enabled:false, energy:0, cd:0},
      shield:{active:false, mesh:null},
      t:0, trailClock:0,
      highs:[],
    };

    // ---------- High Scores ----------
    function loadScores(){ try{ state.highs = JSON.parse(localStorage.getItem('swb_highs')||'[]'); }catch{ state.highs=[]; } updateHiscoreUI(); }
    function saveScore(score){ state.highs.push({score, date:Date.now()}); state.highs.sort((a,b)=>b.score-a.score); state.highs = state.highs.slice(0,5); localStorage.setItem('swb_highs', JSON.stringify(state.highs)); updateHiscoreUI(); }
    function updateHiscoreUI(){ hud.hiscoreList.textContent = state.highs.length? state.highs.map(h=>h.score).join(' â€¢ '): 'â€”'; }

    // ---------- Init ----------
    function init(){
      loadScores();
      renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      camera = new THREE.OrthographicCamera(-world.WIDTH/2, world.WIDTH/2, world.HEIGHT/2, -world.HEIGHT/2, -100, 100);
      camera.position.z = 10;
      camera.lookAt(0,0,0); // ensure we're looking at origin

      // Background full-screen quad
      const bgGeo = new THREE.PlaneGeometry(world.WIDTH, world.HEIGHT);
      const bgMat = new THREE.ShaderMaterial({ vertexShader: BG_VERT, fragmentShader: BG_FRAG, depthTest:false, uniforms:{ uTime:{value:0}, uIntensity:{value:0.6} } });
      bgMesh = new THREE.Mesh(bgGeo, bgMat); bgMesh.position.z = -50; bgMesh.renderOrder = -1; scene.add(bgMesh);

      // Walls
      const wallMat = new THREE.MeshBasicMaterial({ color:0x162033 });
      const walls = new THREE.Group();
      const t = world.WALL_THICK, W=world.WIDTH, H=world.HEIGHT;
      walls.add(new THREE.Mesh(new THREE.PlaneGeometry(W, t), wallMat)); walls.children[0].position.set(0, H/2+t/2, 0);
      walls.add(new THREE.Mesh(new THREE.PlaneGeometry(W, t), wallMat)); walls.children[1].position.set(0, -H/2-t/2, 0);
      walls.add(new THREE.Mesh(new THREE.PlaneGeometry(t, H), wallMat)); walls.children[2].position.set(-W/2-t/2, 0, 0);
      walls.add(new THREE.Mesh(new THREE.PlaneGeometry(t, H), wallMat)); walls.children[3].position.set(W/2+t/2, 0, 0);
      scene.add(walls);

      // Shield visual
      const shieldGeo = new THREE.PlaneGeometry(world.WIDTH-6, 4);
      const shieldMat = new THREE.ShaderMaterial({ vertexShader: BG_VERT, fragmentShader: SHIELD_FRAG, side:THREE.DoubleSide, blending:THREE.AdditiveBlending, transparent:true, depthWrite:false, uniforms:{ uColor:{value:COLORS.neonGreen}, uPulse:{value:0} } });
      const shield = new THREE.Mesh(shieldGeo, shieldMat); shield.position.set(0, -world.HEIGHT/2 + 2.5, 0.02); shield.visible=false; scene.add(shield);
      state.shield.mesh = shield;

      // Post-processing
      composer = new EffectComposer(renderer);
      const rp = new RenderPass(scene, camera); composer.addPass(rp);
      bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.7, 0.8, 0.85); // softer
      composer.addPass(bloomPass);

      // Input
      window.addEventListener('resize', onResize);
      window.addEventListener('mousemove', onMouse);
      window.addEventListener('touchmove', onTouch, {passive:false});
      window.addEventListener('keydown', onKey);
      window.addEventListener('mousedown', onMouseDown);
      window.addEventListener('touchstart', onTouchStart, {passive:false});

      makePaddle();
      loadLevel(state.levelIndex);
      updateHUD();
    }

    function onResize(){
      renderer.setSize(innerWidth, innerHeight);
      camera.left = -world.WIDTH/2; camera.right = world.WIDTH/2; 
      camera.top = world.HEIGHT/2; camera.bottom = -world.HEIGHT/2; camera.updateProjectionMatrix();
      composer.setSize(innerWidth, innerHeight);
    }

    // ---------- Entities ----------
    let paddle; 
    function makePaddle(){
      const g = new THREE.PlaneGeometry(CONFIG.PADDLE.WIDTH, CONFIG.PADDLE.HEIGHT);
      const m = new THREE.ShaderMaterial({ vertexShader: BG_VERT, fragmentShader: NEON_FRAG, side:THREE.DoubleSide, transparent:false, uniforms:{ uColor:{value:COLORS.neonCyan}, uTime:{value:0}, uHit:{value:0} } });
      paddle = new THREE.Mesh(g,m); paddle.position.set(0, -world.HEIGHT/2 + 8, 0); scene.add(paddle);
      paddle.width = CONFIG.PADDLE.WIDTH; paddle.height = CONFIG.PADDLE.HEIGHT;
      paddle.sticky = false;
    }

    function makeBall(x,y, vx=rand(-1,1)*CONFIG.BALL.SPEED, vy=CONFIG.BALL.SPEED){
      const g = new THREE.CircleGeometry(CONFIG.BALL.RADIUS, 24);
      const m = new THREE.MeshBasicMaterial({ color: COLORS.white, transparent:true });
      const s = new THREE.Mesh(g,m); s.position.set(x,y,0); s.userData.vel = new THREE.Vector2(vx, vy);
      s.userData.stuck = true; s.userData.trailClock = 0; 
      scene.add(s); state.balls.push(s);
      return s;
    }

    function makeTrail(x,y){
      const g = new THREE.PlaneGeometry(CONFIG.TRAIL.SIZE, CONFIG.TRAIL.SIZE);
      const m = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.9, blending:THREE.AdditiveBlending, depthWrite:false });
      const q = new THREE.Mesh(g,m); q.position.set(x,y,0.01); q.userData={t:0}; q.rotation.z = rand(0,6.283); scene.add(q); state.trails.push(q);
      return q;
    }

    function makeBrick(x,y,type, rowIndex){
      const w=8.5,h=3.5; const g=new THREE.PlaneGeometry(w,h);
      const baseColor = [COLORS.neonPurple, COLORS.neonCyan, COLORS.steel, COLORS.neonMagenta, COLORS.neonCyan][type-1] || COLORS.neonPurple;
      const m = new THREE.ShaderMaterial({ vertexShader: BG_VERT, fragmentShader: NEON_FRAG, side:THREE.DoubleSide, uniforms:{ uColor:{value:baseColor.clone()}, uTime:{value:0}, uHit:{value:0} } });
      const mesh = new THREE.Mesh(g,m); mesh.position.set(x,y,0); mesh.userData={ type, hp: type===2?2: (type===3?999:1), baseX:x, row:rowIndex };
      scene.add(mesh); state.bricks.push(mesh);
      const ampMul = (currentLevel.rowMoves||[])[rowIndex]||0; if(ampMul>0){ state.movers.push({mesh, amp:CONFIG.MOVERS.AMP*ampMul, speed:CONFIG.MOVERS.SPEED*(1+rowIndex*0.1), phase: rand(0,6.283)}); }
    }

    function spawnPowerup(x,y){
      const g = new THREE.PlaneGeometry(3,3); const m = new THREE.MeshBasicMaterial({ color: 0xffff66 });
      const p = new THREE.Mesh(g,m); p.position.set(x,y,0); p.userData={ vy:-CONFIG.POWERUPS.FALL_SPEED, kind: pickPower() };
      scene.add(p); state.powerups.push(p);
    }

    function pickPower(){
      const kinds = ['PADDLE','SLOW','MULTI','LASER','STICKY','SHIELD'];
      return kinds[Math.floor(rand(0,kinds.length))];
    }

    function spawnImpact(x,y,color=COLORS.neonMagenta){
      const g = new THREE.PlaneGeometry(10,10);
      const m = new THREE.ShaderMaterial({ vertexShader: BG_VERT, fragmentShader: RING_FRAG, blending:THREE.AdditiveBlending, transparent:true, depthWrite:false, uniforms:{ uColor:{value:color}, uTime:{value:0} } });
      const ring = new THREE.Mesh(g,m); ring.position.set(x,y,0.1); ring.userData.t=0; scene.add(ring); state.effects.push(ring);
    }

    function fireLaser(){
      if(!state.laser.enabled || state.laser.energy < CONFIG.LASER.COST || state.laser.cd>0) return;
      state.laser.energy -= CONFIG.LASER.COST; state.laser.cd = CONFIG.LASER.COOLDOWN;
      const w=0.8, h=8; const g=new THREE.PlaneGeometry(h,w);
      const m=new THREE.ShaderMaterial({ vertexShader: BG_VERT, fragmentShader: LASER_FRAG, blending:THREE.AdditiveBlending, transparent:true, depthWrite:false, uniforms:{ uColor:{value:COLORS.neonMagenta} } });
      const beam=new THREE.Mesh(g,m); beam.rotation.z = Math.PI/2; beam.position.set(paddle.position.x, paddle.position.y+4, 0.05);
      beam.userData = { vy: CONFIG.LASER.SPEED };
      scene.add(beam); state.projectiles.push(beam);
      AudioSys.laser();
    }

    // ---------- Level Loading ----------
    let currentLevel = LEVELS[0];
    function loadLevel(i){
      clearLevel();
      currentLevel = LEVELS[i % LEVELS.length];
      const cols = currentLevel.rows[0].length; const rows = currentLevel.rows.length;
      const gutterX = 1.2, gutterY=1.0; const brickW=8.5, brickH=3.5;
      const totalW = cols*brickW + (cols-1)*gutterX; const startX = -totalW/2 + brickW/2; const startY = world.HEIGHT/2 - 18; 
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const code = currentLevel.rows[r][c]; if(!code) continue;
          const x = startX + c*(brickW+gutterX);
          const y = startY - r*(brickH+gutterY);
          makeBrick(x,y, code, r);
        }
      }
      makeBall(paddle.position.x, paddle.position.y + 5, rand(-30,30), CONFIG.BALL.SPEED);
      updateHUD();
    }

    function clearLevel(){
      for(const arr of [state.balls,state.bricks,state.powerups,state.projectiles,state.effects,state.trails]){
        for(const o of arr){ scene.remove(o); o.geometry?.dispose?.(); o.material?.dispose?.(); }
        arr.length=0;
      }
      state.movers.length=0;
    }

    // ---------- Input ----------
    function onMouse(e){ if(!paddle) return; const nx = (e.clientX/innerWidth)*2-1; paddle.position.x = clamp(nx*world.WIDTH/2, -world.WIDTH/2+10, world.WIDTH/2-10); }
    function onTouch(e){ if(!paddle) return; const t=e.touches[0]; const nx=(t.clientX/innerWidth)*2-1; paddle.position.x = clamp(nx*world.WIDTH/2, -world.WIDTH/2+10, world.WIDTH/2-10); }
    function onKey(e){ if(e.code==='Space'){ launchOrFire(); } if(e.code==='KeyP'){ togglePause(); } }
    function onMouseDown(){ launchOrFire(); }
    function onTouchStart(e){ e.preventDefault(); launchOrFire(); }
    function launchOrFire(){
      let anyStuck=false; for(const b of state.balls){ if(b.userData.stuck){ anyStuck=true; b.userData.stuck=false; b.userData.vel.set(rand(-1,1)*CONFIG.BALL.SPEED, CONFIG.BALL.SPEED); } }
      if(!anyStuck) fireLaser();
    }

    function togglePause(){ if(!state.running) return; state.paused = !state.paused; hud.menu.style.display = state.paused? 'flex':'none'; hud.menu.querySelector('h1').textContent = state.paused? 'Paused' : 'ðŸŸ£ SYNTHWAVE BREAKOUT'; }

    // ---------- Collision Helpers ----------
    function aabb(x,y,w,h, px,py,r){ const cx = clamp(px, x-w/2, x+w/2); const cy = clamp(py, y-h/2, y+h/2); const dx = px - cx; const dy = py - cy; return dx*dx + dy*dy <= r*r; }

    // ---------- Game Loop ----------
    let last=performance.now();
    function loop(now){
      requestAnimationFrame(loop);
      const dt = Math.min(0.033, (now-last)/1000); last=now; if(!state.running||state.paused) { composer.render(); return; }

      state.t += dt; state.trailClock += dt;

      // animate bg (dimmer)
      bgMesh.material.uniforms.uTime.value += dt; 
      const tscale = SETTINGS.reduceFlashing? 0.6:1.0;
      bgMesh.material.uniforms.uIntensity.value = 0.5 + 0.1*Math.sin(now*0.001*tscale);

      // Paddle shader time
      paddle.material.uniforms.uTime.value += dt;
      if (paddle.material.uniforms.uHit.value>0) paddle.material.uniforms.uHit.value = Math.max(0, paddle.material.uniforms.uHit.value - dt);

      // Shield pulse
      if(state.shield.mesh){ state.shield.mesh.material.uniforms.uPulse.value = state.t; }

      // Laser cooldown
      state.laser.cd = Math.max(0, state.laser.cd - dt);

      // Movers (moving brick rows)
      for(const mv of state.movers){ mv.mesh.position.x = mv.mesh.userData.baseX + Math.sin(state.t*mv.speed + mv.phase)*mv.amp; }

      // Update balls
      const r = CONFIG.BALL.RADIUS; const W=world.WIDTH/2, H=world.HEIGHT/2;
      for(const b of state.balls){
        b.material.opacity = SETTINGS.highContrast? 1.0: 0.9;
        if(b.userData.stuck){ b.position.x = paddle.position.x; b.position.y = paddle.position.y + 5; continue; }
        const v = b.userData.vel;
        b.position.x += v.x*dt; b.position.y += v.y*dt;

        // Trail spawn
        b.userData.trailClock = (b.userData.trailClock||0) + dt; 
        if(b.userData.trailClock > CONFIG.TRAIL.SPAWN_DT){ b.userData.trailClock = 0; const q=makeTrail(b.position.x, b.position.y); q.material.opacity = SETTINGS.reduceFlashing? 0.5:0.9; }

        // wall bounce
        if(b.position.x<-W+r){ b.position.x=-W+r; v.x=Math.abs(v.x); AudioSys.bounce(); }
        if(b.position.x> W-r){ b.position.x= W-r; v.x=-Math.abs(v.x); AudioSys.bounce(); }
        if(b.position.y> H-r){ b.position.y= H-r; v.y=-Math.abs(v.y); AudioSys.bounce(); }
        if(b.position.y< -H+r){ // lost or shield
          if(state.shield.active){
            b.position.y = -H + r + 1.5; v.y = Math.abs(v.y); state.shield.active=false; state.shield.mesh.visible=false; spawnImpact(b.position.x, -H+3, COLORS.neonGreen); AudioSys.power();
          } else {
            scene.remove(b); state.balls.splice(state.balls.indexOf(b),1); continue;
          }
        }
        // paddle collide
        if(aabb(paddle.position.x, paddle.position.y, paddle.width, paddle.height, b.position.x, b.position.y, r)){
          b.position.y = paddle.position.y + paddle.height/2 + r; v.y = Math.abs(v.y);
          const off = (b.position.x - paddle.position.x)/(paddle.width/2); v.x = clamp(v.x + off*40, -CONFIG.BALL.MAX_SPEED, CONFIG.BALL.MAX_SPEED);
          paddle.material.uniforms.uHit.value = 1.0; AudioSys.bounce();
          if(paddle.sticky){ b.userData.stuck=true; }
        }
        // brick collide
        for(const brick of [...state.bricks]){
          const w=8.5,h=3.5; if(!aabb(brick.position.x, brick.position.y, w,h, b.position.x, b.position.y, r)) continue;
          const dx = (b.position.x - brick.position.x)/w; const dy=(b.position.y - brick.position.y)/h;
          if(Math.abs(dx) > Math.abs(dy)) { v.x *= -1; } else { v.y *= -1; }
          hitBrick(brick, b.position.x, b.position.y);
          state.laser.energy = Math.min(100, state.laser.energy + CONFIG.LASER.RECHARGE_HIT);
          break;
        }
      }

      // Lost all balls
      if(state.balls.length===0){ state.lives--; state.mult=1; AudioSys.lose(); if(state.lives<0){ gameOver(); } else { makeBall(paddle.position.x, paddle.position.y+5, rand(-30,30), CONFIG.BALL.SPEED); } updateHUD(); }

      // Powerups fall
      for(const p of [...state.powerups]){
        p.position.y += p.userData.vy*dt;
        if(p.position.y < -H-2){ scene.remove(p); state.powerups.splice(state.powerups.indexOf(p),1); continue; }
        if(Math.abs(p.position.x - paddle.position.x) < paddle.width/2 && Math.abs(p.position.y - paddle.position.y) < paddle.height){
          applyPower(p.userData.kind); spawnImpact(p.position.x, p.position.y, COLORS.neonCyan); scene.remove(p); state.powerups.splice(state.powerups.indexOf(p),1); AudioSys.power();
        }
      }

      // Projectiles
      for(const pr of [...state.projectiles]){
        pr.position.y += pr.userData.vy*dt; if(pr.position.y>H+5){ scene.remove(pr); state.projectiles.splice(state.projectiles.indexOf(pr),1); continue; }
        for(const brick of [...state.bricks]){
          if(Math.abs(pr.position.x - brick.position.x) < 4.5 && Math.abs(pr.position.y - brick.position.y) < 2.5){
            hitBrick(brick, pr.position.x, pr.position.y, true);
            scene.remove(pr); state.projectiles.splice(state.projectiles.indexOf(pr),1); break;
          }
        }
      }

      // Effects & Trails
      for(const fx of [...state.effects]){ fx.userData.t += dt; fx.material.uniforms.uTime.value = fx.userData.t; if(fx.userData.t>1.0){ scene.remove(fx); state.effects.splice(state.effects.indexOf(fx),1); } }
      for(const tr of [...state.trails]){ tr.userData.t += dt; tr.material.opacity = Math.max(0, 0.9*(1 - tr.userData.t/CONFIG.TRAIL.LIFE)); tr.scale.multiplyScalar(0.985); if(tr.userData.t>CONFIG.TRAIL.LIFE){ scene.remove(tr); state.trails.splice(state.trails.indexOf(tr),1); } }

      // Brick shader time
      for(const br of state.bricks){ br.material.uniforms.uTime.value += dt; if (br.material.uniforms.uHit.value>0) br.material.uniforms.uHit.value = Math.max(0, br.material.uniforms.uHit.value - dt*2.5); }

      // Level clear
      if(state.bricks.length===0){ state.levelIndex++; state.score += 500; AudioSys.level(); loadLevel(state.levelIndex); }

      updateHUD();

      if(SETTINGS.bloom){ composer.render(); } else { renderer.render(scene,camera); }
    }

    function hitBrick(brick, x,y, piercing=false){
      const t = brick.userData.type; 
      brick.material.uniforms.uHit.value = 1.0; 
      spawnImpact(x,y, t===3? COLORS.steel : COLORS.neonMagenta);
      if(t===3){ AudioSys.steel(); }
      else if(t===2){ brick.userData.hp--; state.score += CONFIG.SCORE.ARMORED/2; AudioSys.armored(); if(brick.userData.hp<=0){ destroyBrick(brick, true); } }
      else if(t===4){ destroyBrick(brick, true); for(const b of [...state.bricks]){ if(b===brick) continue; if(b.position.distanceTo(brick.position) < 12){ destroyBrick(b, false); } } AudioSys.brick(); }
      else { destroyBrick(brick, true); AudioSys.brick(); }
      if(!piercing){ /* placeholder for non-piercing logic */ }
    }

    function destroyBrick(brick, dropChance){
      scene.remove(brick); state.bricks.splice(state.bricks.indexOf(brick),1);
      const t=brick.userData.type; const add = t===4?CONFIG.SCORE.EXPLOSIVE : t===2?CONFIG.SCORE.ARMORED : CONFIG.SCORE.BASE; 
      state.score += Math.round(add * state.mult);
      state.mult = clamp(state.mult + 0.05, 1, CONFIG.SCORE.MULT_MAX);
      if(Math.random() < CONFIG.POWERUPS.CHANCE && dropChance){ spawnPowerup(brick.position.x, brick.position.y); }
    }

    function applyPower(kind){
      switch(kind){
        case 'PADDLE': paddle.scale.x = clamp(paddle.scale.x*1.25, 1, CONFIG.PADDLE.MAX_WIDTH/CONFIG.PADDLE.WIDTH); break;
        case 'SLOW': for(const b of state.balls){ b.userData.vel.multiplyScalar(0.8); } break;
        case 'MULTI': { const src = state.balls[0]; if(!src) break; for(let i=0;i<2;i++){ const nb = makeBall(src.position.x, src.position.y, rand(-1,1)*CONFIG.BALL.SPEED, CONFIG.BALL.SPEED); nb.userData.stuck=false; } } break;
        case 'LASER': state.laser.enabled = true; state.laser.energy = Math.min(100, state.laser.energy + 50); break;
        case 'STICKY': paddle.sticky = true; setTimeout(()=> paddle.sticky=false, CONFIG.POWERUPS.DURATION*1000); break;
        case 'SHIELD': state.shield.active = true; state.shield.mesh.visible=true; break;
      }
    }

    function updateHUD(){
      hud.score.textContent = `Score: ${state.score}`;
      hud.lives.textContent = `Lives: ${state.lives}`;
      hud.level.textContent = `Level: ${state.levelIndex+1}`;
      hud.mult.textContent = `x${state.mult.toFixed(1)}`;
      hud.weapon.textContent = `Laser: ${state.laser.enabled? 'ON':'OFF'}`;
      hud.energy.textContent = `Energy: ${Math.round(state.laser.energy)}%`;
      hud.shield.textContent = `Shield: ${state.shield.active? 'ON':'OFF'}`;
    }

    function gameOver(){
      state.running=false;
      hud.menu.style.display='flex';
      hud.menu.querySelector('h1').textContent='Game Over';
      saveScore(state.score);
      updateHiscoreUI();
    }

    // ---------- Start / Restart ----------
    function resetGame(){
      state.running=false; state.paused=false;
      state.levelIndex=0; state.score=0; state.lives=3; state.mult=1;
      state.laser={enabled:false, energy:0, cd:0};
      state.shield.active=false; if(state.shield.mesh) state.shield.mesh.visible=false;
      state.t=0; state.trailClock=0;
      clearLevel();
      loadLevel(0);
      updateHUD();
    }

    hud.startBtn.addEventListener('click', ()=>{
      // Always start a fresh run
      resetGame();
      state.running=true; state.paused=false; hud.menu.style.display='none';
      last=performance.now();
      hud.menu.querySelector('h1').textContent='ðŸŸ£ SYNTHWAVE BREAKOUT';
    });

    // ---------- UI ----------
    hud.toggleBloom.addEventListener('click', ()=>{ SETTINGS.bloom = !SETTINGS.bloom; });
    hud.toggleFlash.addEventListener('click', ()=>{ SETTINGS.reduceFlashing = !SETTINGS.reduceFlashing; });
    hud.resetScores.addEventListener('click', ()=>{ localStorage.removeItem('swb_highs'); state.highs=[]; updateHiscoreUI(); });

    init(); requestAnimationFrame(loop);
  </script>
</body>
</html>